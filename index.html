<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Portfolio Physics Wall (Puzzle Slots)</title>
  <style>
    * {
      box-sizing: border-box;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #ffffff;
    }
    canvas {
      position: fixed;
      inset: 0;
      display: block;
      background: #ffffff;
      touch-action: none; /* 모바일에서 기본 스크롤/줌 방지 */
    }

    #intro {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      font-size: 1.05rem;
      color: #999;
      text-align: center;
      padding: 0 16px;
      transition: opacity 0.3s ease;
      z-index: 5;
      line-height: 1.6;
    }
    #intro.hidden {
      opacity: 0;
    }

    /* 가운데 모달용 오버레이 */
    .detail-overlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.25);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 10;
    }
    .detail-overlay.open {
      opacity: 1;
      pointer-events: auto;
    }

    .detail-modal {
      width: min(480px, 80vw);
      max-height: min(70vh, 90vh);
      background: rgba(255,255,255,0.98);
      border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0,0,0,0.22);
      padding: 20px 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      animation: pop-in 0.22s ease-out;
    }

    @keyframes pop-in {
      from {
        transform: translateY(6px) scale(0.96);
        opacity: 0;
      }
      to {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
    }

    .detail-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 8px;
    }
    .detail-title {
      font-size: 1.05rem;
      font-weight: 600;
    }
    .detail-tag {
      font-size: 0.8rem;
      color: #777;
      margin-top: 4px;
    }
    .detail-close {
      border: none;
      background: transparent;
      font-size: 1.3rem;
      line-height: 1;
      cursor: pointer;
      padding: 4px 6px;
      margin: -4px -4px 0 0;
    }
    .detail-body {
      font-size: 0.9rem;
      color: #444;
      line-height: 1.6;
      overflow-y: auto;
      padding-right: 4px;
    }
    .detail-meta {
      font-size: 0.78rem;
      color: #999;
      margin-top: 4px;
    }

    /* ====== 모바일(좁은 화면)에서 확실히 크게 ====== */
    @media (max-width: 900px) {
      #intro {
        font-size: 1.3rem;
        padding: 0 28px;
      }
      .detail-modal {
        width: 94vw;
        max-height: 80vh;
        border-radius: 18px;
        padding: 22px 20px;
      }
      .detail-title {
        font-size: 1.35rem;
      }
      .detail-tag {
        font-size: 0.95rem;
      }
      .detail-body {
        font-size: 1.05rem;
      }
      .detail-meta {
        font-size: 0.9rem;
      }
      .detail-close {
        font-size: 1.6rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="intro">
    어디든 한 번 탭/클릭하면 작업들이 우르르 떨어집니다.<br />
    도형을 드래그해서 움직이고, 톡 클릭하면 설명이 떠요.
  </div>

  <!-- 중앙 모달 오버레이 -->
  <div class="detail-overlay" id="detailOverlay">
    <div class="detail-modal">
      <div class="detail-header">
        <div>
          <div class="detail-title" id="detailTitle">작업 제목</div>
          <div class="detail-tag" id="detailTag">카테고리 / 연도</div>
        </div>
        <button class="detail-close" id="detailClose" aria-label="닫기">×</button>
      </div>
      <div class="detail-body" id="detailBody">
        여기에 작업 설명이 들어갑니다.
      </div>
      <div class="detail-meta" id="detailMeta"></div>
    </div>
  </div>

  <script>
    // ===== 캔버스 / 기본 세팅 =====
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const intro = document.getElementById('intro');

    const detailOverlay = document.getElementById('detailOverlay');
    const detailTitle = document.getElementById('detailTitle');
    const detailTag = document.getElementById('detailTag');
    const detailBody = document.getElementById('detailBody');
    const detailMeta = document.getElementById('detailMeta');
    const detailClose = document.getElementById('detailClose');

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    const MOBILE_BREAKPOINT = 900;
    const isMobile = () => window.innerWidth <= MOBILE_BREAKPOINT;

    // ===== 작업 데이터 (슬롯 비율 포함) =====
    const works = [
      {
        id: 'work-1',
        title: '포스터 시리즈 A',
        tag: 'Graphic / 2024',
        description: '굵은 타이포와 제한된 컬러 팔레트로 리듬을 만든 포스터 시리즈입니다.',
        meta: 'Size: 700×1000mm · Tool: Photoshop, Illustrator',
        slotW: 2,   // 가로 2
        slotH: 3    // 세로 3 (세로 긴 포맷)
      },
      {
        id: 'work-2',
        title: '웹 인터랙션 실험',
        tag: 'Interactive / 2025',
        description: '스크롤과 물리 기반 움직임을 결합한 인터랙티브 웹 실험입니다.',
        meta: 'Prototype · HTML/CSS/JS',
        slotW: 3,   // 가로 긴 포맷
        slotH: 2
      },
      {
        id: 'work-3',
        title: '브랜딩 콘셉트 B',
        tag: 'Branding / 2023',
        description: '소셜 이슈와 연결된 브랜드 톤앤매너를 시각 언어로 정리한 프로젝트입니다.',
        meta: 'Logo · Stationery · SNS kit',
        slotW: 2,
        slotH: 2    // 정사각형 느낌
      },
      {
        id: 'work-4',
        title: '에디토리얼 레이아웃',
        tag: 'Editorial / 2023',
        description: '텍스트 밀도가 높은 글을 읽기 쉽게 재배열한 에디토리얼 디자인입니다.',
        meta: '80p · InDesign, Typography',
        slotW: 3,
        slotH: 4    // 세로 더 긴 포맷
      },
      {
        id: 'work-5',
        title: '동적 아이덴티티',
        tag: 'Motion / 2024',
        description: '로고와 모션 그래픽을 묶어 시스템 형태로 구성한 아이덴티티 실험입니다.',
        meta: 'Motion System · After Effects',
        slotW: 2,
        slotH: 2
      }
    ];

    // ===== 도형 배열 =====
    const shapes = [];
    let hasSpawned = false;

    function randomColor() {
      const palette = [
        '#f6a5c0',
        '#9ad0f5',
        '#f9dd8a',
        '#c3f0b8',
        '#d1b2ff',
        '#ffd6a5',
        '#bdb2ff',
        '#ffc6ff'
      ];
      return palette[Math.floor(Math.random() * palette.length)];
    }

    function spawnShapes() {
      const w = canvas.width;
      const h = canvas.height;
      shapes.length = 0;

      const mobile = isMobile();

      const count = mobile ? works.length : works.length * 2;
      const baseUnit = mobile ? 40 : 30; // 블럭 기본 단위 (조절해서 전체 크기 튜닝)

      for (let i = 0; i < count; i++) {
        const work = works[i % works.length];

        const slotW = work.slotW || 2;
        const slotH = work.slotH || 2;

        // 실제 픽셀 단위 크기
        const halfW = slotW * baseUnit;
        const halfH = slotH * baseUnit;

        const x = halfW + Math.random() * (w - 2 * halfW);
        const y = -200 - Math.random() * 300;
        const vx = (Math.random() - 0.5) * (mobile ? 40 : 60);
        const vy = 0;

        shapes.push({
          id: work.id,
          x,
          y,
          vx,
          vy,
          halfW,
          halfH,
          color: randomColor(),
          work,
          isDragging: false
        });
      }
    }

    // ===== 물리 업데이트 =====
    const gravity = 800;
    const damping = 0.8;
    const restitution = 0.5;
    let lastTime = null;

    function update(dt) {
      const w = canvas.width;
      const h = canvas.height;

      for (const s of shapes) {
        if (!s.isDragging) {
          s.vy += gravity * dt;
          s.x += s.vx * dt;
          s.y += s.vy * dt;
        }

        // 좌우 벽 (사각형 기준)
        if (s.x - s.halfW < 0) {
          s.x = s.halfW;
          if (s.vx < 0) s.vx = -s.vx * damping;
        }
        if (s.x + s.halfW > w) {
          s.x = w - s.halfW;
          if (s.vx > 0) s.vx = -s.vx * damping;
        }

        // 바닥
        if (s.y + s.halfH > h) {
          s.y = h - s.halfH;
          if (s.vy > 0) s.vy = -s.vy * damping;
        }

        // 천장
        if (s.y - s.halfH < 0) {
          s.y = s.halfH;
          if (s.vy < 0) s.vy = -s.vy * damping;
        }
      }

      // ===== 도형 간 충돌 (AABB 사각형) =====
      for (let i = 0; i < shapes.length; i++) {
        for (let j = i + 1; j < shapes.length; j++) {
          const a = shapes[i];
          const b = shapes[j];

          const dx = b.x - a.x;
          const dy = b.y - a.y;

          const overlapX = (a.halfW + b.halfW) - Math.abs(dx);
          if (overlapX <= 0) continue;

          const overlapY = (a.halfH + b.halfH) - Math.abs(dy);
          if (overlapY <= 0) continue;

          // 어느 축으로 더 겹쳤는지에 따라 분리 방향 결정
          if (overlapX < overlapY) {
            // X축으로 밀어내기
            const signX = dx < 0 ? -1 : 1;

            if (a.isDragging && !b.isDragging) {
              b.x += signX * overlapX;
            } else if (b.isDragging && !a.isDragging) {
              a.x -= signX * overlapX;
            } else {
              a.x -= signX * overlapX * 0.5;
              b.x += signX * overlapX * 0.5;
            }

            const relVx = b.vx - a.vx;
            if (relVx * signX < 0) {
              const jImpulse = -(1 + restitution) * relVx / 2;
              a.vx -= jImpulse;
              b.vx += jImpulse;
              a.vx *= damping;
              b.vx *= damping;
            }
          } else {
            // Y축으로 밀어내기
            const signY = dy < 0 ? -1 : 1;

            if (a.isDragging && !b.isDragging) {
              b.y += signY * overlapY;
            } else if (b.isDragging && !a.isDragging) {
              a.y -= signY * overlapY;
            } else {
              a.y -= signY * overlapY * 0.5;
              b.y += signY * overlapY * 0.5;
            }

            const relVy = b.vy - a.vy;
            if (relVy * signY < 0) {
              const jImpulse = -(1 + restitution) * relVy / 2;
              a.vy -= jImpulse;
              b.vy += jImpulse;
              a.vy *= damping;
              b.vy *= damping;
            }
          }
        }
      }
    }

    // ===== 라운드 사각형 Path 유틸 =====
    function roundRectPath(ctx, cx, cy, halfW, halfH, radius) {
      const x = cx - halfW;
      const y = cy - halfH;
      const w = halfW * 2;
      const h = halfH * 2;
      const r = Math.min(radius, w / 2, h / 2);

      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.lineTo(x + w - r, y);
      ctx.quadraticCurveTo(x + w, y, x + w, y + r);
      ctx.lineTo(x + w, y + h - r);
      ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
      ctx.lineTo(x + r, y + h);
      ctx.quadraticCurveTo(x, y + h, x, y + h - r);
      ctx.lineTo(x, y + r);
      ctx.quadraticCurveTo(x, y, x + r, y);
      ctx.closePath();
    }

    // ===== 렌더링 =====
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const mobile = isMobile();

      for (const s of shapes) {
        const cornerRadius = mobile ? 20 : 14;
        roundRectPath(ctx, s.x, s.y, s.halfW, s.halfH, cornerRadius);
        ctx.fillStyle = s.color;
        ctx.fill();

        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        ctx.font = mobile ? '700 20px system-ui' : '500 13px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(s.id.replace('work-', '#'), s.x, s.y);
      }
    }

    function loop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = Math.min((timestamp - lastTime) / 1000, 0.03);
      lastTime = timestamp;

      if (shapes.length > 0) {
        update(dt);
        draw();
      } else {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }

      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    // ===== 상세 모달 =====
    function showDetail(work) {
      detailTitle.textContent = work.title;
      detailTag.textContent = work.tag;
      detailBody.textContent = work.description;
      detailMeta.textContent = work.meta || '';
      detailOverlay.classList.add('open');
    }
    function hideDetail() {
      detailOverlay.classList.remove('open');
    }

    detailClose.addEventListener('click', hideDetail);
    detailOverlay.addEventListener('click', (e) => {
      if (e.target === detailOverlay) hideDetail();
    });

    // ===== 포인터(마우스 + 터치) 공통 상태 =====
    let isPointerDown = false;
    let dragTarget = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let lastPointerX = 0;
    let lastPointerY = 0;
    let pointerDownTime = 0;
    let pointerMovedDistSq = 0;
    let dragHistory = []; // {x, y, t}

    function getShapeAt(x, y) {
      for (let i = shapes.length - 1; i >= 0; i--) {
        const s = shapes[i];
        if (
          x >= s.x - s.halfW &&
          x <= s.x + s.halfW &&
          y >= s.y - s.halfH &&
          y <= s.y + s.halfH
        ) {
          return s;
        }
      }
      return null;
    }

    function pointerDown(x, y) {
      isPointerDown = true;
      lastPointerX = x;
      lastPointerY = y;
      pointerDownTime = performance.now();
      pointerMovedDistSq = 0;
      dragHistory = [];

      const s = getShapeAt(x, y);
      if (s) {
        dragTarget = s;
        dragOffsetX = x - s.x;
        dragOffsetY = y - s.y;
        s.isDragging = true;
      } else {
        dragTarget = null;
      }
    }

    function pointerMove(x, y) {
      if (!isPointerDown || !dragTarget) return;

      const dx = x - lastPointerX;
      const dy = y - lastPointerY;
      pointerMovedDistSq += dx * dx + dy * dy;

      dragTarget.x = x - dragOffsetX;
      dragTarget.y = y - dragOffsetY;

      lastPointerX = x;
      lastPointerY = y;

      const now = performance.now();
      dragHistory.push({ x: dragTarget.x, y: dragTarget.y, t: now });
      if (dragHistory.length > 5) dragHistory.shift();
    }

    function pointerUp(x, y) {
      if (!isPointerDown) return;
      isPointerDown = false;

      const upX = (typeof x === 'number') ? x : lastPointerX;
      const upY = (typeof y === 'number') ? y : lastPointerY;

      const elapsed = performance.now() - pointerDownTime;
      const CLICK_DIST_SQ = 10 * 10;
      const CLICK_TIME = 300;

      let clickedShape = dragTarget || getShapeAt(upX, upY);

      if (dragTarget) {
        dragTarget.isDragging = false;
        if (dragHistory.length >= 2) {
          const a = dragHistory[dragHistory.length - 2];
          const b = dragHistory[dragHistory.length - 1];
          const dtMs = b.t - a.t;
          if (dtMs > 0) {
            const dt = dtMs / 1000;
            const vx = (b.x - a.x) / dt;
            const vy = (b.y - a.y) / dt;
            dragTarget.vx = vx * 0.9;
            dragTarget.vy = vy * 0.9;
          }
        }
      }

      dragTarget = null;
      dragHistory = [];

      if (clickedShape && pointerMovedDistSq <= CLICK_DIST_SQ && elapsed <= CLICK_TIME) {
        showDetail(clickedShape.work);
      }
    }

    // ===== 마우스 이벤트 =====
    canvas.addEventListener('mousedown', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      pointerDown(x, y);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isPointerDown) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      pointerMove(x, y);
    });

    canvas.addEventListener('mouseup', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      pointerUp(x, y);
    });

    window.addEventListener('mouseup', () => {
      if (dragTarget) dragTarget.isDragging = false;
      isPointerDown = false;
      dragTarget = null;
      dragHistory = [];
    });

    // ===== 터치 이벤트 =====
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      pointerDown(x, y);
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (!isPointerDown) return;
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      pointerMove(x, y);
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      pointerUp(lastPointerX, lastPointerY);
    }, { passive: false });

    canvas.addEventListener('touchcancel', (e) => {
      e.preventDefault();
      if (dragTarget) dragTarget.isDragging = false;
      isPointerDown = false;
      dragTarget = null;
      dragHistory = [];
    }, { passive: false });

    // ===== 첫 클릭/탭 시 도형 떨어뜨리기 =====
    function handleFirstActivate() {
      if (!hasSpawned) {
        hasSpawned = true;
        intro.classList.add('hidden');
        spawnShapes();
      }
    }

    document.body.addEventListener('click', function onceClick() {
      handleFirstActivate();
      document.body.removeEventListener('click', onceClick);
    }, { once: true });

    document.body.addEventListener('touchstart', function onceTouch() {
      handleFirstActivate();
      document.body.removeEventListener('touchstart', onceTouch);
    }, { once: true, passive: true });
  </script>
</body>
</html>
